<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>카운트업</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: darkslategray;
            color: #fff;
            height: 3000px;
        }

        .counter_section {
            margin-top: 1000px;
            display: flex;
            gap: 100px;
            justify-content: center;
        }

        .counter_box {
            text-align: center;
        }

        .number {
            font-size: 68px;
            color: rgb(134, 216, 216);
        }

        .label {
            font-size: 20px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <section class="counter_section">
        <div class="counter_box">
            <div class="number" data-target="1500">0</div>
            <div class="label">아바타</div>
        </div>
        <div class="counter_box">
            <div class="number" data-target="550">0</div>
            <div class="label">주토피아</div>
        </div>
        <div class="counter_box">
            <div class="number" data-target="99">0</div>
            <div class="label">짱구극장판</div>
        </div>
    </section>
    <script>
        const numbers = document.querySelectorAll(".number");
        console.log(numbers);

        function animateCounter(counter){
            counter.innerText = "0";
            const target =+ counter.getAttribute("data-target");

            let current = 0;
            const update = ()=>{
                const increment = target/100;
                // target : 1500 / 100 : 15

                if(current < target){
                    current += increment;
                    // 0 = 15 / 15 + 15 = 30
                    counter.innerText = Math.ceil(current);
                    requestAnimationFrame(update);
                    //requestAnimationFrame : 다음 화면을 그릴 때
                    // 15 -> 30 -> 45

                }else {
                    counter.innerText = target.toLocaleString();
                    //current가 목표에 도달했다면 최종적으로 target을 표시함
                    // toLocaleString : 1000단위 넘으면 , 붙여줌
                }
            };

            update(); 
            // 0->15
        }

        const observer = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                if(entry.isIntersecting){
                    //isIntersecting : 변화가 생긴 entry가 화면에 들어왔니? / true / false
                    //  entry가 화면에 보이고있다면 true / 아니면 false
                    animateCounter(entry.target);
                    // target : 감시중인 요소의 dom을 가져옴
                }
            })
        },{
            threshold:0.6
        });
        //IntersectionObserver : 뷰포트를 기준으로 대상 요소가 나타날 때 콜백함수를 호출하는 API
        //우리가 원하는 요소가 화면에 들어왔는지 감시하는 도구 (감시 대상이 화면 안에 들어오거나 밖으로 나가거나 할 때 자동으로 실행됨)
        // entries : 감시중인 요소에 변화가 생기면 변화가 생긴 요소를 entries에 넣음 entries는 요소들을 배열형식으로 보관하는 장소
        // 요소들을 감시하다가 무슨 일이 생기면 엔트리스에 이벤트가 일어난 요소들이 들어가게 됨

        numbers.forEach(num => {
            observer.observe(num);
        });
    </script>
</body>
</html>